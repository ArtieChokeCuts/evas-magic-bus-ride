<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Super Eva's Magic Bus Ride</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    body { 
        overflow: hidden; 
        background: #87ceeb; 
        font-family: 'Comic Sans MS', 'Nunito', sans-serif; 
        touch-action: none; 
    }

    #splash-screen {
        position: fixed; inset: 0; z-index: 100;
        background: #87ceeb url('splash.png') center/cover no-repeat; 
        display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
        padding-bottom: max(10vh, 40px);
    }

    #menu {
        display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;
        width: 85%; max-width: 400px;
    }
    
    select {
        appearance: none; -webkit-appearance: none;
        padding: 15px 20px; font-size: 1.4rem; font-weight: 900; font-family: 'Comic Sans MS', sans-serif;
        background: rgba(255, 255, 255, 0.9); border: 3px solid #ff007f; border-radius: 20px;
        color: #4a2377; box-shadow: 0 8px 20px rgba(0,0,0,0.3); text-align: center;
        outline: none; cursor: pointer;
    }
    
    #start-btn {
        padding: 20px 70px; font-size: 2.2rem; font-weight: 900; border-radius: 50px;
        border: 4px solid rgba(255, 255, 255, 0.4);
        background: linear-gradient(135deg, #ff007f, #ffaa00); color: white; 
        cursor: pointer; box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 4px 10px rgba(255,255,255,0.4);
        text-transform: uppercase; letter-spacing: 2px;
        transition: transform 0.1s;
    }
    #start-btn:active { transform: scale(0.95); }
    #start-btn:disabled { filter: grayscale(1); cursor: not-allowed; }
    
    #ui { 
        position: absolute; top: 15px; width: 100%; display: none; z-index: 10;
        display: flex; justify-content: center; pointer-events: none;
    }
    
    #hud {
      display: flex; justify-content: space-between; align-items: center; width: 95%; max-width: 800px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.2); border-radius: 30px; 
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 2px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 12px 35px rgba(0,0,0,0.2);
    }

    #hud span {
        color: #ffffff; font-weight: 900; font-size: 2.5rem; 
        text-shadow: 0 4px 10px rgba(0,0,0,0.6);
        transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1), color 0.2s;
        display: inline-block;
    }

    canvas { display: block; position: absolute; inset: 0; z-index: 5; }
  </style>
</head>
<body>
  <div id="splash-screen">
    <div id="menu">
      <select id="math-select">
        <option value="1">Count: 1 - 10</option>
        <option value="11">Count: 11 - 25</option>
      </select>
      <select id="spell-select">
        <option value="1">Spell: E-V-A</option>
        <option value="4">Spell: Alphabet</option>
        <option value="30">Spell: Word Bank</option>
      </select>
    </div>
    <button id="start-btn" disabled>LOADING...</button>
  </div>
  
  <div id="ui" style="display:none;">
    <div id="hud">
      <span id="math-level">Math: 1</span>
      <span id="targets">-</span>
      <span id="spell-level">Spell: 1</span>
    </div>
  </div>

  <script>
    // --- AUDIO SETUP ---
    const audio = {
        loop: new Audio('loop.mp3'), pop: new Audio('pop.mp3'),
        magic: new Audio('magic.mp3'), evaTheme: new Audio('eva_theme.mp3')
    };
    audio.loop.loop = true;

    audio.evaTheme.addEventListener('ended', () => {
        if (state.playing) {
            audio.loop.currentTime = 0; 
            audio.loop.play().catch(()=>{});
        }
    });

    // --- GAME LOGIC STATE ---
    const state = {
      playing: false, mathLevel: 1, spellingLevel: 1,
      mathTargets: Array.from({length: 25}, (_, i) => (i + 1).toString()), 
      letterTargets: [
          'E', 'V', 'A', 
          ...('ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')), 
          'A', 'S', 'A', 'B', 'U', 'S', 'D', 'O', 'G', 'C', 'A', 'T'
      ],
      currentMathTarget: '1', currentLetterTarget: 'E',
      mathColors: [0x00ecec, 0x0088ff, 0x7b61ff, 0xffaa00, 0xff0055],
      spellColors: [0xff00ff, 0xff5500, 0xffcc00, 0x00ff55, 0x00ccff]
    };

    // --- ENGINE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.9);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 8);
    scene.add(dirLight);

    const bubbles = [];
    const clouds = [];
    const bursts = [];
    
    let evaSprite;
    let fullscreenTried = false;
    let gameFont = null;

    // Free Movement Tracker
    const targetEvaPos = new THREE.Vector3(0, -2, 0);
    let isDragging = false;

    // --- MAGIC STARDUST ---
    const starGeo = new THREE.BufferGeometry();
    const starCount = 150;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i < starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 30;
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    
    const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
    const ctx = cvs.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const starTex = new THREE.CanvasTexture(cvs);

    const starMat = new THREE.PointsMaterial({
        size: 0.6, map: starTex, transparent: true, 
        opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const starMesh = new THREE.Points(starGeo, starMat);
    scene.add(starMesh);

    function createBurst(x, y, colorHex) {
        const burstGroup = new THREE.Group();
        burstGroup.position.set(x, y, 0);
        
        const particleGeo = new THREE.PlaneGeometry(0.5, 0.5);
        const particleMat = new THREE.MeshBasicMaterial({
            color: colorHex, map: starTex, transparent: true, 
            opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false
        });

        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.15 + Math.random() * 0.15;
            p.userData = { vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 1.0 };
            burstGroup.add(p);
        }
        scene.add(burstGroup);
        bursts.push(burstGroup);
    }

    function disposeGroup(group) {
        group.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose());
                else child.material.dispose();
            }
        });
    }

    // --- LOAD EVA SOUL ---
    new THREE.TextureLoader().load('eva.png', (tex) => {
        const mat = new THREE.SpriteMaterial({ map: tex });
        evaSprite = new THREE.Sprite(mat);
        evaSprite.scale.set(3, 3, 1);
        evaSprite.position.set(0, -2, 0); 
        scene.add(evaSprite);
    });

    function createMovingClouds() {
        const ccvs = document.createElement('canvas'); ccvs.width = 256; ccvs.height = 128;
        const c = ccvs.getContext('2d');
        c.fillStyle = "rgba(255, 255, 255, 0.6)";
        c.beginPath(); c.arc(128,64,50,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(80,64,35,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(176,64,35,0,Math.PI*2); c.fill();
        const tex = new THREE.CanvasTexture(ccvs);

        for(let i=0; i<10; i++) {
            const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            s.scale.set(10, 5, 1);
            s.position.set((Math.random()-0.5)*30, Math.random()*10, (Math.random()-0.5)*15 - 5);
            s.userData = { speed: 0.003 + Math.random()*0.008 };
            clouds.push(s); scene.add(s);
        }
    }
    createMovingClouds();

    function createBubble(value, colorHex, x, y, type) {
      if (!gameFont) return null;
      const group = new THREE.Group();

      const textGeo = new THREE.TextGeometry(value.toString(), {
        font: gameFont, size: 0.9, height: 0.2, 
        curveSegments: 12, bevelEnabled: true,
        bevelThickness: 0.02, bevelSize: 0.015, bevelSegments: 3
      });
      
      textGeo.computeBoundingBox();
      const xOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
      const yOffset = -0.5 * (textGeo.boundingBox.max.y - textGeo.boundingBox.min.y);
      
      const textMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6, roughness: 0.2 });
      const textMesh = new THREE.Mesh(textGeo, textMat);
      textMesh.position.set(xOffset, yOffset, 0);
      group.add(textMesh);

      const ringGeo = new THREE.TorusGeometry(1.2, 0.1, 16, 64);
      const ringMat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
      const ringMesh = new THREE.Mesh(ringGeo, ringMat);
      group.add(ringMesh);

      group.position.set(x, y, 0);
      group.rotation.x = -0.15;
      group.rotation.y = 0.15;

      group.userData = { 
        value, type, colorHex, popScale: 1, popping: false, 
        speed: 0.025 + Math.random()*0.02,
        pulseOffset: Math.random() * Math.PI * 2,
        ringMesh: ringMesh 
      };
      
      scene.add(group);
      bubbles.push(group);
      return group;
    }

    function pulseHUD(id) {
        const el = document.getElementById(id);
        el.style.transform = 'scale(1.4)';
        el.style.color = '#ffeb3b'; 
        setTimeout(() => {
            el.style.transform = 'scale(1)';
            el.style.color = '#ffffff';
        }, 300);
    }

    function updateHud(pulseId = null) {
      document.getElementById('math-level').textContent = `Math: ${state.mathLevel}`;
      document.getElementById('spell-level').textContent = `Spell: ${state.spellingLevel}`;
      document.getElementById('targets').textContent = `${state.currentMathTarget} & ${state.currentLetterTarget}`;
      if (pulseId) pulseHUD(pulseId);
      pulseHUD('targets'); 
    }

    function advanceTarget(type) {
      let pulseTarget = null;
      if (type === 'math') {
        state.mathLevel += 1;
        state.currentMathTarget = state.mathTargets[(state.mathLevel - 1) % state.mathTargets.length];
        pulseTarget = 'math-level';
      } else {
        state.spellingLevel += 1;
        state.currentLetterTarget = state.letterTargets[(state.spellingLevel - 1) % state.letterTargets.length];
        pulseTarget = 'spell-level';
        
        if (state.spellingLevel === 4) {
          if (!audio.loop.paused) audio.loop.pause();
          if (!audio.magic.paused) { audio.magic.pause(); audio.magic.currentTime = 0; }
          if (!audio.evaTheme.paused) { audio.evaTheme.pause(); audio.evaTheme.currentTime = 0; }
          audio.evaTheme.play().catch(()=>{});
          updateHud(pulseTarget);
          return; 
        }
      }
      audio.magic.currentTime = 0; audio.magic.play().catch(()=>{});
      updateHud(pulseTarget);
    }

    function respawnBubble(group) {
      const type = group.userData.type;
      const val = type === 'math' ? state.currentMathTarget : state.currentLetterTarget;
      const colorArr = type === 'math' ? state.mathColors : state.spellColors;
      const level = type === 'math' ? state.mathLevel : state.spellingLevel;
      const activeColor = colorArr[(level - 1) % colorArr.length];

      const newX = type === 'math' ? -2.2 - Math.random() * 1.5 : 2.2 + Math.random() * 1.5;
      const newY = -8; 

      createBubble(val, activeColor, newX, newY, type);
    }

    function popBubble(group) {
      if (!group || group.userData.popping) return;
      group.userData.popping = true;

      createBurst(group.position.x, group.position.y, group.userData.colorHex);
      audio.pop.currentTime = 0; audio.pop.play().catch(()=>{});

      if (group.userData.type === 'math' && group.userData.value === state.currentMathTarget) advanceTarget('math');
      if (group.userData.type === 'spelling' && group.userData.value === state.currentLetterTarget) advanceTarget('spelling');
    }

    // --- FREE MOVEMENT CONTROLS ---
    function updateEvaTarget(clientX, clientY) {
      const vec = new THREE.Vector3(
          (clientX / window.innerWidth) * 2 - 1,
          -(clientY / window.innerHeight) * 2 + 1,
          0.5
      );
      vec.unproject(camera);
      vec.sub(camera.position).normalize();
      const distance = -camera.position.z / vec.z;
      
      const pos = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
      
      // Clamp her within the visible screen area
      targetEvaPos.x = Math.max(-4, Math.min(4, pos.x));
      targetEvaPos.y = Math.max(-5, Math.min(6, pos.y));
    }

    window.addEventListener('pointerdown', (e) => {
      if (!state.playing || e.target.closest('#menu') || e.target.closest('#start-btn')) return;
      isDragging = true;
      updateEvaTarget(e.clientX, e.clientY);
    });

    window.addEventListener('pointermove', (e) => {
      if (!state.playing || !isDragging) return;
      updateEvaTarget(e.clientX, e.clientY);
    });

    window.addEventListener('pointerup', () => { isDragging = false; });
    window.addEventListener('pointercancel', () => { isDragging = false; });

    async function requestFullscreenSafe() {
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } catch (_) {}
    }

    function lockPortraitSafe() {
      try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(() => {}); } catch (_) {}
    }

    const loader = new THREE.FontLoader();
    loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
        gameFont = font;
        const btn = document.getElementById('start-btn');
        btn.textContent = 'RIDE!';
        btn.disabled = false;
    });

    let startRequested = false;
    document.getElementById('start-btn').addEventListener('click', async (e) => {
        e.preventDefault();
        if (startRequested || state.playing || !gameFont) return;
        startRequested = true;

        await requestFullscreenSafe();
        lockPortraitSafe();

        // Lock in the settings from the menu
        state.mathLevel = parseInt(document.getElementById('math-select').value);
        state.spellingLevel = parseInt(document.getElementById('spell-select').value);
        state.currentMathTarget = state.mathTargets[(state.mathLevel - 1) % state.mathTargets.length];
        state.currentLetterTarget = state.letterTargets[(state.spellingLevel - 1) % state.letterTargets.length];

        // Seed initial targets based on menu choice
        createBubble(state.currentMathTarget, state.mathColors[(state.mathLevel - 1) % state.mathColors.length], -2.2, -2, 'math');
        createBubble(state.currentLetterTarget, state.spellColors[(state.spellingLevel - 1) % state.spellColors.length], 2.2, -4, 'spelling');
        updateHud(); 

        document.getElementById('splash-screen').style.display = 'none';
        
        const ui = document.getElementById('ui');
        ui.style.display = 'flex';
        ui.style.opacity = '0';
        setTimeout(() => { ui.style.transition = 'opacity 0.5s'; ui.style.opacity = '1'; }, 100);

        state.playing = true;
        audio.loop.play().catch(()=>{});
    });

    window.addEventListener('pointerdown', async () => {
      if (fullscreenTried) return;
      fullscreenTried = true;
      await requestFullscreenSafe();
      lockPortraitSafe();
    }, { once: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- ANIMATION ENGINE ---
    function animate() {
      requestAnimationFrame(animate);
      
      if (state.playing) {
          clouds.forEach(c => { 
              c.position.x += c.userData.speed; 
              if(c.position.x > 15) c.position.x = -15; 
          });
          
          starMesh.position.y -= 0.02;
          starMesh.rotation.y += 0.001;
          if(starMesh.position.y < -10) starMesh.position.y = 10;

          // Free movement lerp and idle bob
          if (evaSprite) {
              if (isDragging) {
                  evaSprite.position.lerp(targetEvaPos, 0.2);
              } else {
                  evaSprite.position.y += Math.sin(Date.now()*0.003)*0.005;
              }
          }

          for(let i = bursts.length - 1; i >= 0; i--) {
              const b = bursts[i];
              let alive = false;
              b.children.forEach(p => {
                  p.position.x += p.userData.vx;
                  p.position.y += p.userData.vy;
                  p.userData.life -= 0.04; 
                  p.material.opacity = Math.max(p.userData.life, 0);
                  const s = Math.max(p.userData.life, 0);
                  p.scale.set(s, s, s);
                  if (p.userData.life > 0) alive = true;
              });
              if (!alive) {
                  scene.remove(b);
                  disposeGroup(b);
                  bursts.splice(i, 1);
              }
          }

          for (let i = bubbles.length - 1; i >= 0; i -= 1) {
            const group = bubbles[i];
            
            if (!group.userData.popping) {
                group.position.y += group.userData.speed;
                group.rotation.y += 0.015;
                group.rotation.x = Math.sin(Date.now()*0.002) * 0.2;
                
                const pulse = 1 + Math.sin(Date.now() * 0.005 + group.userData.pulseOffset) * 0.15;
                group.userData.ringMesh.scale.set(pulse, pulse, 1);

                // Proximity Collision Detonation
                if (evaSprite && evaSprite.position.distanceTo(group.position) < 1.8) {
                    popBubble(group);
                } else if (group.position.y > 8) {
                    scene.remove(group);
                    bubbles.splice(i, 1);
                    disposeGroup(group);
                    respawnBubble(group);
                }
            } else {
              group.userData.popScale -= 0.15; 
              const s = Math.max(group.userData.popScale, 0);
              group.scale.set(s, s, s); 
              
              if (group.userData.popScale <= 0) {
                scene.remove(group);
                bubbles.splice(i, 1);
                disposeGroup(group);
                respawnBubble(group);
              }
            }
          }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
