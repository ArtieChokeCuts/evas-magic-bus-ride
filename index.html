<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Super Eva's Magic Bus Ride</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <style>
    /* --- PREMIUM VISUALS & MASSIVE UI --- */
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    body { 
        overflow: hidden; 
        background: radial-gradient(circle at 50% 100%, #4a2377 0%, #2948ff 40%, #0cd7e8 100%);
        font-family: 'Comic Sans MS', 'Nunito', sans-serif; 
        touch-action: none; 
    }

    #splash-screen {
        position: fixed; inset: 0; z-index: 100;
        background: radial-gradient(circle at 50% 100%, #4a2377 0%, #2948ff 40%, #0cd7e8 100%);
        display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
        padding-bottom: max(12vh, 60px);
    }
    
    #start-btn {
        padding: 20px 70px; font-size: 2.2rem; font-weight: 900; border-radius: 50px;
        border: 4px solid rgba(255, 255, 255, 0.4);
        background: linear-gradient(135deg, #ff007f, #ffaa00); color: white; 
        cursor: pointer; box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 4px 10px rgba(255,255,255,0.4);
        text-transform: uppercase; letter-spacing: 2px;
        transition: transform 0.1s;
    }
    #start-btn:active { transform: scale(0.95); }
    
    #ui { 
        position: absolute; top: 15px; width: 100%; display: none; z-index: 10;
        display: flex; justify-content: center; pointer-events: none;
    }
    
    /* Massive Glassmorphism HUD */
    #hud {
      display: flex; justify-content: space-between; align-items: center; width: 95%; max-width: 800px;
      padding: 15px 30px;
      background: rgba(255, 255, 255, 0.15); border-radius: 30px; 
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border: 2px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 12px 35px rgba(0,0,0,0.3);
    }

    #hud span {
        color: #ffffff; font-weight: 900; font-size: 2.5rem; /* Massive font for progression */
        text-shadow: 0 4px 10px rgba(0,0,0,0.6);
        transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1), color 0.2s;
        display: inline-block;
    }

    .laneBtn { -webkit-tap-highlight-color: transparent; pointer-events: auto; }
    .laneBtn:active { background: rgba(255,255,255,0.05); }
    canvas { display: block; position: absolute; inset: 0; z-index: 5; }
  </style>
</head>
<body>
  <div id="splash-screen">
    <button id="start-btn">RIDE!</button>
  </div>
  
  <div id="ui" style="display:none;">
    <div id="hud">
      <span id="math-level">Math: 1</span>
      <span id="targets">11 & E</span>
      <span id="spell-level">Spell: 1</span>
    </div>
  </div>

  <div id="touch-lanes" style="position:fixed; inset:0; z-index:11; display:none; grid-template-columns: 1fr 1fr 1fr; gap: 0;">
    <button class="laneBtn" data-lane="-1" aria-label="Left lane" style="background:transparent; border:none; outline:none;"></button>
    <button class="laneBtn" data-lane="0" aria-label="Middle lane" style="background:transparent; border:none; outline:none;"></button>
    <button class="laneBtn" data-lane="1" aria-label="Right lane" style="background:transparent; border:none; outline:none;"></button>
  </div>

  <script>
    // --- AUDIO SETUP ---
    const audio = {
        loop: new Audio('loop.mp3'), pop: new Audio('pop.mp3'),
        magic: new Audio('magic.mp3'), evaTheme: new Audio('eva_theme.mp3')
    };
    audio.loop.loop = true;

    // --- GAME LOGIC STATE (4YO VISUAL CURRICULUM) ---
    const state = {
      playing: false, lane: 0, mathLevel: 1, spellingLevel: 1,
      // 1-5 Counting -> Evens -> Simple 10s
      mathTargets: ['1', '2', '3', '4', '5', '2', '4', '6', '10', '20'], 
      // Her Identity -> Her Dog -> Her Environment
      letterTargets: ['E', 'V', 'A', 'A', 'S', 'A', 'B', 'U', 'S'],
      currentMathTarget: '1', currentLetterTarget: 'E',
      
      // Visual Scaling Arrays (Hex colors shift as she levels up)
      mathColors: [0x00ecec, 0x0088ff, 0x7b61ff, 0xffaa00, 0xff0055],
      spellColors: [0xff00ff, 0xff5500, 0xffcc00, 0x00ff55, 0x00ccff]
    };

    // --- ENGINE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- STUDIO LIGHTING ---
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 8);
    scene.add(dirLight);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const bubbles = [];
    const clouds = [];
    const bursts = [];
    const laneSpacing = 3.2;
    const laneTolerance = 3.0;
    let evaSprite;
    let fullscreenTried = false;
    let gameFont = null;

    // --- MAGIC STARDUST PARTICLE ENGINE ---
    const starGeo = new THREE.BufferGeometry();
    const starCount = 150;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i < starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 30;
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    
    const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
    const ctx = cvs.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const starTex = new THREE.CanvasTexture(cvs);

    const starMat = new THREE.PointsMaterial({
        size: 0.6, map: starTex, transparent: true, 
        opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const starMesh = new THREE.Points(starGeo, starMat);
    scene.add(starMesh);

    // --- BURST EXPLOSION LOGIC ---
    function createBurst(x, y, colorHex) {
        const burstGroup = new THREE.Group();
        burstGroup.position.set(x, y, 0);
        
        const particleGeo = new THREE.PlaneGeometry(0.5, 0.5);
        const particleMat = new THREE.MeshBasicMaterial({
            color: colorHex, map: starTex, transparent: true, 
            opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false
        });

        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.15 + Math.random() * 0.15;
            p.userData = { vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 1.0 };
            burstGroup.add(p);
        }
        scene.add(burstGroup);
        bursts.push(burstGroup);
    }

    // --- MEMORY MANAGEMENT ---
    function disposeGroup(group) {
        group.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose());
                else child.material.dispose();
            }
        });
    }

    // --- LOAD EVA SOUL ---
    new THREE.TextureLoader().load('eva.png', (tex) => {
        const mat = new THREE.SpriteMaterial({ map: tex });
        evaSprite = new THREE.Sprite(mat);
        evaSprite.scale.set(3, 3, 1);
        evaSprite.position.set(0, -2, 0); 
        scene.add(evaSprite);
    });

    // --- LOAD CLOUDS ---
    function createMovingClouds() {
        const ccvs = document.createElement('canvas'); ccvs.width = 256; ccvs.height = 128;
        const c = ccvs.getContext('2d');
        c.fillStyle = "rgba(255, 255, 255, 0.6)";
        c.beginPath(); c.arc(128,64,50,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(80,64,35,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(176,64,35,0,Math.PI*2); c.fill();
        const tex = new THREE.CanvasTexture(ccvs);

        for(let i=0; i<10; i++) {
            const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            s.scale.set(10, 5, 1);
            s.position.set((Math.random()-0.5)*30, Math.random()*10, (Math.random()-0.5)*15 - 5);
            s.userData = { speed: 0.003 + Math.random()*0.008 };
            clouds.push(s); scene.add(s);
        }
    }
    createMovingClouds();

    // --- 3D TARGET BRAINS ---
    function createBubble(value, colorHex, x, y, type) {
      if (!gameFont) return null;

      const group = new THREE.Group();

      const textGeo = new THREE.TextGeometry(value.toString(), {
        font: gameFont, size: 1.4, height: 0.3, 
        curveSegments: 12, bevelEnabled: true,
        bevelThickness: 0.04, bevelSize: 0.03, bevelSegments: 4
      });
      
      textGeo.computeBoundingBox();
      const xOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
      const yOffset = -0.5 * (textGeo.boundingBox.max.y - textGeo.boundingBox.min.y);
      
      const textMat = new THREE.MeshStandardMaterial({ 
          color: 0xffffff, metalness: 0.8, roughness: 0.1 
      });
      const textMesh = new THREE.Mesh(textGeo, textMat);
      textMesh.position.set(xOffset, yOffset, 0);
      group.add(textMesh);

      const ringGeo = new THREE.TorusGeometry(1.8, 0.12, 16, 64);
      const ringMat = new THREE.MeshBasicMaterial({ 
        color: colorHex, transparent: true, opacity: 0.8,
        blending: THREE.AdditiveBlending 
      });
      const ringMesh = new THREE.Mesh(ringGeo, ringMat);
      group.add(ringMesh);

      group.position.set(x, y, 0);
      group.rotation.x = -0.15;
      group.rotation.y = 0.15;

      group.userData = { 
        value, type, colorHex, popScale: 1, popping: false, 
        speed: 0.025 + Math.random()*0.02,
        pulseOffset: Math.random() * Math.PI * 2,
        ringMesh: ringMesh 
      };
      
      scene.add(group);
      bubbles.push(group);
      return group;
    }

    // --- HUD ANIMATION & LOGIC ---
    function pulseHUD(id) {
        const el = document.getElementById(id);
        el.style.transform = 'scale(1.4)';
        el.style.color = '#ffeb3b'; // Flash gold
        setTimeout(() => {
            el.style.transform = 'scale(1)';
            el.style.color = '#ffffff';
        }, 300);
    }

    function updateHud(pulseId = null) {
      document.getElementById('math-level').textContent = `Math: ${state.mathLevel}`;
      document.getElementById('spell-level').textContent = `Spell: ${state.spellingLevel}`;
      document.getElementById('targets').textContent = `${state.currentMathTarget} & ${state.currentLetterTarget}`;
      
      // Pulse the specific score that just increased
      if (pulseId) pulseHUD(pulseId);
      pulseHUD('targets'); // Always pulse the middle target string so she sees the new goal
    }

    function advanceTarget(type) {
      let pulseTarget = null;
      if (type === 'math') {
        state.mathLevel += 1;
        state.currentMathTarget = state.mathTargets[(state.mathLevel - 1) % state.mathTargets.length];
        pulseTarget = 'math-level';
      } else {
        state.spellingLevel += 1;
        state.currentLetterTarget = state.letterTargets[(state.spellingLevel - 1) % state.letterTargets.length];
        pulseTarget = 'spell-level';
        
        // Trigger theme cleanly when E-V-A is finished (Level 4)
        if (state.spellingLevel === 4) {
          if (!audio.loop.paused) audio.loop.pause();
          if (!audio.magic.paused) { audio.magic.pause(); audio.magic.currentTime = 0; }
          if (!audio.evaTheme.paused) { audio.evaTheme.pause(); audio.evaTheme.currentTime = 0; }
          audio.evaTheme.play().catch(()=>{});
          updateHud(pulseTarget);
          return; 
        }
      }
      audio.magic.currentTime = 0; audio.magic.play().catch(()=>{});
      updateHud(pulseTarget);
    }

    function respawnBubble(group) {
      const type = group.userData.type;
      const val = type === 'math' ? state.currentMathTarget : state.currentLetterTarget;
      
      const colorArr = type === 'math' ? state.mathColors : state.spellColors;
      const level = type === 'math' ? state.mathLevel : state.spellingLevel;
      const activeColor = colorArr[(level - 1) % colorArr.length];

      const newX = type === 'math' ? -3 - Math.random() * 2 : 3 + Math.random() * 2;
      const newY = -8; 

      createBubble(val, activeColor, newX, newY, type);
    }

    function popBubble(group) {
      if (!group || group.userData.popping) return;
      group.userData.popping = true;

      // Trigger the stardust explosion using the group's current color
      createBurst(group.position.x, group.position.y, group.userData.colorHex);

      audio.pop.currentTime = 0; audio.pop.play().catch(()=>{});

      if (group.userData.type === 'math' && group.userData.value === state.currentMathTarget) advanceTarget('math');
      if (group.userData.type === 'spelling' && group.userData.value === state.currentLetterTarget) advanceTarget('spelling');
    }

    function findClosestBubbleInLane(lane) {
      const laneX = lane * laneSpacing;
      let best = null;
      let bestScore = Infinity;

      for (const b of bubbles) {
        if (b.userData.popping) continue;
        if (Math.abs(b.position.x - laneX) > laneTolerance) continue;
        const score = Math.abs(b.position.y - (evaSprite ? evaSprite.position.y : -2));
        if (score < bestScore) { bestScore = score; best = b; }
      }
      return best;
    }

    function handlePointer(event) {
      if (!state.playing) return;
      if (event.target.closest && event.target.closest('#touch-lanes')) return;
      pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);

      const activeGroups = bubbles.filter((b) => !b.userData.popping);
      const activeMeshes = [];
      activeGroups.forEach(g => activeMeshes.push(...g.children));

      const intersects = raycaster.intersectObjects(activeMeshes);
      if (intersects.length === 0) return;
      
      popBubble(intersects[0].object.parent);
    }

    async function requestFullscreenSafe() {
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } catch (_) {}
    }

    function lockPortraitSafe() {
      try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(() => {}); } catch (_) {}
    }

    // --- ASYNC FONT LOAD ---
    const loader = new THREE.FontLoader();
    loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
        gameFont = font;
        createBubble(state.currentMathTarget, state.mathColors[0], -3, -2, 'math');
        createBubble(state.currentLetterTarget, state.spellColors[0], 3, -4, 'spelling');
        updateHud(); // Initial draw
    });

    let startRequested = false;
    async function startGame(event) {
        if (event) event.preventDefault();
        if (startRequested || state.playing) return;
        startRequested = true;

        await requestFullscreenSafe();
        lockPortraitSafe();
        document.getElementById('splash-screen').style.display = 'none';
        
        // Delay HUD display slightly for smooth transition
        const ui = document.getElementById('ui');
        ui.style.display = 'flex';
        ui.style.opacity = '0';
        setTimeout(() => { ui.style.transition = 'opacity 0.5s'; ui.style.opacity = '1'; }, 100);

        document.getElementById('touch-lanes').style.display = 'grid';
        state.playing = true;
        audio.loop.play().catch(()=>{});
    }

    const touchLanes = document.getElementById('touch-lanes');
    touchLanes.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('.laneBtn');
      if (!btn || !state.playing) return;
      e.preventDefault();

      const lane = Number(btn.dataset.lane);
      state.lane = lane;
      if (evaSprite) evaSprite.position.x = lane * laneSpacing;

      const target = findClosestBubbleInLane(lane);
      if (target) popBubble(target); 
    }, { passive: false });

    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('pointerdown', startGame, { passive: false });
    window.addEventListener('pointerdown', async () => {
      if (fullscreenTried) return;
      fullscreenTried = true;
      await requestFullscreenSafe();
      lockPortraitSafe();
    }, { once: true });
    window.addEventListener('pointerdown', handlePointer);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- ANIMATION ENGINE ---
    function animate() {
      requestAnimationFrame(animate);
      
      if (state.playing) {
          clouds.forEach(c => { 
              c.position.x += c.userData.speed; 
              if(c.position.x > 15) c.position.x = -15; 
          });
          
          starMesh.position.y -= 0.02;
          starMesh.rotation.y += 0.001;
          if(starMesh.position.y < -10) starMesh.position.y = 10;

          if (evaSprite) evaSprite.position.y = -2 + Math.sin(Date.now()*0.003)*0.15;

          // Animate particle bursts
          for(let i = bursts.length - 1; i >= 0; i--) {
              const b = bursts[i];
              let alive = false;
              b.children.forEach(p => {
                  p.position.x += p.userData.vx;
                  p.position.y += p.userData.vy;
                  p.userData.life -= 0.04; // Fade speed
                  p.material.opacity = Math.max(p.userData.life, 0);
                  const s = Math.max(p.userData.life, 0);
                  p.scale.set(s, s, s);
                  if (p.userData.life > 0) alive = true;
              });
              if (!alive) {
                  scene.remove(b);
                  disposeGroup(b);
                  bursts.splice(i, 1);
              }
          }

          // Target Logic
          for (let i = bubbles.length - 1; i >= 0; i -= 1) {
            const group = bubbles[i];
            
            if (!group.userData.popping) {
                group.position.y += group.userData.speed;
                group.rotation.y += 0.015;
                group.rotation.x = Math.sin(Date.now()*0.002) * 0.2;
                
                const pulse = 1 + Math.sin(Date.now() * 0.005 + group.userData.pulseOffset) * 0.15;
                group.userData.ringMesh.scale.set(pulse, pulse, 1);

                if (group.position.y > 8) {
                    scene.remove(group);
                    bubbles.splice(i, 1);
                    disposeGroup(group);
                    respawnBubble(group);
                }
            } else {
              group.userData.popScale -= 0.15; 
              const s = Math.max(group.userData.popScale, 0);
              group.scale.set(s, s, s); 
              
              if (group.userData.popScale <= 0) {
                scene.remove(group);
                bubbles.splice(i, 1);
                disposeGroup(group);
                respawnBubble(group);
              }
            }
          }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
