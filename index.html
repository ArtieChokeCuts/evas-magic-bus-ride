<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Super Eva's Magic Bus Ride</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    /* --- CORE VISUALS --- */
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    body { 
        overflow: hidden; 
        background: #87ceeb;
        font-family: 'Comic Sans MS', Arial, sans-serif; 
        touch-action: none; 
    }

    /* --- UI --- */
    #splash-screen {
        position: fixed; inset: 0; z-index: 100;
        background: #87ceeb url('splash.png') center/cover no-repeat;
        display: flex; align-items: flex-end; justify-content: center;
        padding-bottom: max(8vh, 48px);
    }
    #start-btn {
        padding: 20px 60px; font-size: 2rem; font-weight: 900; border-radius: 50px;
        border: none; background: #ffc107; color: white; cursor: pointer; box-shadow: 0 8px 16px rgba(0,0,0,0.35);
        margin: 0 auto;
    }
    
    #ui {
      position: absolute; top: 10px; width: 100%; text-align: center; z-index: 10; display: none;
    }
    #hud {
      display: inline-flex; gap: 14px; margin-top: 8px; padding: 8px 12px;
      background: rgba(255, 255, 255, 0.85); border-radius: 12px; color: #4f3fb2; font-weight: 700;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1); font-size: 1.2rem;
    }
    .laneBtn { -webkit-tap-highlight-color: transparent; }
    .laneBtn:active { background: rgba(255,255,255,0.06); }
    canvas { display: block; position: absolute; inset: 0; z-index: 5; }
  </style>
</head>
<body>
  <div id="splash-screen">
    <button id="start-btn">PLAY!</button>
  </div>
  
  <div id="ui">
    <div id="hud">
      <span id="math-level">Math Level: 1</span>
      <span id="spell-level">Spelling Level: 1</span>
      <span id="targets">Targets: 11 & E</span>
    </div>
  </div>

  <div id="touch-lanes" style="
    position:fixed; inset:0; z-index:11;
    display:none;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 0;
  ">
    <button class="laneBtn" data-lane="-1" aria-label="Left lane"
      style="background:transparent; border:none; outline:none;"></button>
    <button class="laneBtn" data-lane="0" aria-label="Middle lane"
      style="background:transparent; border:none; outline:none;"></button>
    <button class="laneBtn" data-lane="1" aria-label="Right lane"
      style="background:transparent; border:none; outline:none;"></button>
  </div>

  <script>
    // --- AUDIO SETUP ---
    const audio = {
        loop: new Audio('loop.mp3'),
        pop: new Audio('pop.mp3'),
        magic: new Audio('magic.mp3'),
        evaTheme: new Audio('eva_theme.mp3')
    };
    audio.loop.loop = true;

    // --- GAME LOGIC STATE ---
    const state = {
      playing: false,
      lane: 0,
      mathLevel: 1, spellingLevel: 1,
      mathTargets: ['11', '9', '7', '13'],
      letterTargets: ['E', 'V', 'A', 'B'],
      currentMathTarget: '11',
      currentLetterTarget: 'E'
    };

    // --- ENGINE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const bubbles = [];
    const clouds = [];
    const laneSpacing = 3;
    const laneTolerance = 2.8;
    let evaSprite;
    let fullscreenTried = false;

    // --- LOAD EVA SOUL ---
    new THREE.TextureLoader().load('eva.png', (tex) => {
        const mat = new THREE.SpriteMaterial({ map: tex });
        evaSprite = new THREE.Sprite(mat);
        evaSprite.scale.set(2.5, 2.5, 1);
        evaSprite.position.set(0, -2, 0); 
        scene.add(evaSprite);
    });

    // --- LOAD CLOUDS SOUL ---
    function createMovingClouds() {
        const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 64;
        const c = cvs.getContext('2d');
        c.fillStyle = "white";
        c.beginPath(); c.arc(64,32,30,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(40,32,20,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(88,32,20,0,Math.PI*2); c.fill();
        const tex = new THREE.CanvasTexture(cvs);

        for(let i=0; i<12; i++) {
            const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.9 }));
            s.scale.set(6, 3, 1);
            s.position.set((Math.random()-0.5)*20, Math.random()*6, (Math.random()-0.5)*10 - 2);
            s.userData = { speed: 0.005 + Math.random()*0.01 };
            clouds.push(s); scene.add(s);
        }
    }
    createMovingClouds();

    // --- BUBBLE & HUD BRAINS ---
    const BUBBLE_RADIUS = 0.92;

    function drawBubbleLabel(ctx, value) {
      const text = String(value);
      const maxWidth = 160;
      let fontSize = 112;

      ctx.font = `bold ${fontSize}px Arial`;
      while (fontSize > 64 && ctx.measureText(text).width > maxWidth) {
        fontSize -= 4;
        ctx.font = `bold ${fontSize}px Arial`;
      }

      ctx.fillStyle = 'white';
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 8;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeText(text, 128, 128);
      ctx.fillText(text, 128, 128);
    }

    function createBubble(value, color, x, y, type) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256; canvas.height = 256;

      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(128, 128, 120, 0, Math.PI * 2); ctx.fill();
      drawBubbleLabel(ctx, value);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshPhongMaterial({ map: texture, transparent: true, opacity: 0.9 });
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(BUBBLE_RADIUS, 32, 32), material);
      sphere.position.set(x, y, 0);
      
      // Speed logic: Float up slowly
      sphere.userData = { value, type, popScale: 1, popping: false, speed: 0.02 + Math.random()*0.02 };
      
      scene.add(sphere);
      bubbles.push(sphere);
      return sphere;
    }


    function advanceTarget(type) {
      if (type === 'math') {
        state.mathLevel += 1;
        state.currentMathTarget = state.mathTargets[(state.mathLevel - 1) % state.mathTargets.length];
      } else {
        state.spellingLevel += 1;
        state.currentLetterTarget = state.letterTargets[(state.spellingLevel - 1) % state.letterTargets.length];
        
        // Easter Egg: If they hit 'A' finishing E-V-A, trigger the theme song
        // Never overlap the theme: only play if it's currently idle.
        if (state.currentLetterTarget === 'B' && (audio.evaTheme.paused || audio.evaTheme.ended)) {
            audio.evaTheme.currentTime = 0;
            audio.evaTheme.play().catch(()=>{});
        }
      }
      audio.magic.currentTime = 0; audio.magic.play().catch(()=>{});
      updateHud();
    }


    function popBubble(hit) {
      if (!hit || hit.userData.popping) return;
      hit.userData.popping = true;

      audio.pop.currentTime = 0; audio.pop.play().catch(()=>{});

      if (hit.userData.type === 'math' && hit.userData.value === state.currentMathTarget) advanceTarget('math');
      if (hit.userData.type === 'spelling' && hit.userData.value === state.currentLetterTarget) advanceTarget('spelling');
    }

    function findClosestBubbleInLane(lane) {
      const laneX = lane * laneSpacing;
      let best = null;
      let bestScore = Infinity;

      for (const b of bubbles) {
        if (b.userData.popping) continue;
        if (Math.abs(b.position.x - laneX) > laneTolerance) continue;
        const score = Math.abs(b.position.y - (evaSprite ? evaSprite.position.y : -2));
        if (score < bestScore) {
          bestScore = score;
          best = b;
        }
      }
      return best;
    }

    function popBubble(hit) {
      if (!hit || hit.userData.popping) return;
      hit.userData.popping = true;

      audio.pop.currentTime = 0; audio.pop.play().catch(()=>{});

      if (hit.userData.type === 'math' && hit.userData.value === state.currentMathTarget) advanceTarget('math');
      if (hit.userData.type === 'spelling' && hit.userData.value === state.currentLetterTarget) advanceTarget('spelling');
    }

    function findClosestBubbleInLane(lane) {
      const laneX = lane * laneSpacing;
      let best = null;
      let bestScore = Infinity;

      for (const b of bubbles) {
        if (b.userData.popping) continue;
        if (Math.abs(b.position.x - laneX) > laneTolerance) continue;
        const score = Math.abs(b.position.y - (evaSprite ? evaSprite.position.y : -2));
        if (score < bestScore) {
          bestScore = score;
          best = b;
        }
      }
      return best;
    }

    function handlePointer(event) {
      if (!state.playing) return;
      if (event.target.closest && event.target.closest('#touch-lanes')) return;
      pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);

      const active = bubbles.filter((b) => !b.userData.popping);
      const intersects = raycaster.intersectObjects(active);
      if (intersects.length === 0) return;
      popBubble(intersects[0].object);
    }

    async function requestFullscreenSafe() {
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } catch (_) {}
    }

    function lockPortraitSafe() {
      try {
        if (screen.orientation && screen.orientation.lock) {
          screen.orientation.lock('portrait').catch(() => {});
        }
      } catch (_) {}
    }


    let startRequested = false;
    async function startGame(event) {
        if (event) event.preventDefault();
        if (startRequested || state.playing) return;
        startRequested = true;

        await requestFullscreenSafe();
        lockPortraitSafe();
        document.getElementById('splash-screen').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('touch-lanes').style.display = 'grid';
        state.playing = true;
        audio.loop.play().catch(()=>{});
    }

    const touchLanes = document.getElementById('touch-lanes');
    touchLanes.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('.laneBtn');
      if (!btn || !state.playing) return;
      e.preventDefault();

      const lane = Number(btn.dataset.lane);
      state.lane = lane;
      if (evaSprite) evaSprite.position.x = lane * laneSpacing;

      const target = findClosestBubbleInLane(lane);
      if (target) popBubble(target);
    }, { passive: false });

    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('pointerdown', startGame, { passive: false });
    window.addEventListener('pointerdown', async () => {
      if (fullscreenTried) return;
      fullscreenTried = true;
      await requestFullscreenSafe();
      lockPortraitSafe();
    }, { once: true });
    window.addEventListener('pointerdown', handlePointer);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- ANIMATION ENGINE ---
    function animate() {
      requestAnimationFrame(animate);
      
      if (state.playing) {
          // Move clouds
          clouds.forEach(c => { 
              c.position.x += c.userData.speed; 
              if(c.position.x > 10) c.position.x = -10; 
          });
          
          // Bob Eva
          if (evaSprite) evaSprite.position.y = -2 + Math.sin(Date.now()*0.002)*0.1;

          // Float and pop bubbles
          for (let i = bubbles.length - 1; i >= 0; i -= 1) {
            const obj = bubbles[i];
            obj.rotation.y += 0.01;
            
            if (!obj.userData.popping) {
                obj.position.y += obj.userData.speed;
                // If it floats off screen, recycle it
                if (obj.position.y > 6) {
                    scene.remove(obj);
                    bubbles.splice(i, 1);
                    respawnBubble(obj);
                }
            } else {
              obj.userData.popScale -= 0.08;
              obj.scale.setScalar(Math.max(obj.userData.popScale, 0));
              if (obj.userData.popScale <= 0) {
                scene.remove(obj);
                bubbles.splice(i, 1);
                respawnBubble(obj);
              }
            }
          }
      }
      renderer.render(scene, camera);
    }
    audio.evaTheme.play();
  }
