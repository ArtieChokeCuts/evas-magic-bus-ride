<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Super Eva's Magic Bus Ride</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    body { 
        overflow: hidden; 
        background: #87ceeb; 
        transition: background 2s ease-in-out; 
        font-family: 'Comic Sans MS', 'Nunito', sans-serif; 
        touch-action: none; 
    }

    #splash-screen {
        position: fixed; inset: 0; z-index: 100;
        background: #87ceeb url('splash.png') center/cover no-repeat; 
        display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
        padding-bottom: max(10vh, 40px);
    }

    #menu {
        display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;
        width: 85%; max-width: 400px;
    }
    
    select {
        appearance: none; -webkit-appearance: none;
        padding: 15px 20px; font-size: 1.4rem; font-weight: 900; font-family: 'Comic Sans MS', sans-serif;
        background: rgba(255, 255, 255, 0.9); border: 3px solid #ff007f; border-radius: 20px;
        color: #4a2377; box-shadow: 0 8px 20px rgba(0,0,0,0.3); text-align: center;
        outline: none; cursor: pointer;
    }
    
    #start-btn {
        padding: 20px 70px; font-size: 2.2rem; font-weight: 900; border-radius: 50px;
        border: 4px solid rgba(255, 255, 255, 0.4);
        background: linear-gradient(135deg, #ff007f, #ffaa00); color: white; 
        cursor: pointer; box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 4px 10px rgba(255,255,255,0.4);
        text-transform: uppercase; letter-spacing: 2px;
        transition: transform 0.1s;
    }
    #start-btn:active { transform: scale(0.95); }
    #start-btn:disabled { filter: grayscale(1); cursor: not-allowed; }
    
    #ui { 
        position: absolute; top: 15px; width: 100%; display: none; z-index: 10;
        display: flex; justify-content: center; pointer-events: none;
    }
    
    #hud {
      display: flex; justify-content: center; gap: 30px; align-items: center; width: 95%; max-width: 800px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.2); border-radius: 30px; 
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 2px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 12px 35px rgba(0,0,0,0.2);
    }

    #hud span {
        color: #ffffff; font-weight: 900; font-size: 2.6rem; 
        text-shadow: 0 4px 10px rgba(0,0,0,0.6);
        transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1), color 0.2s;
        display: inline-block;
    }

    canvas { display: block; position: absolute; inset: 0; z-index: 5; }
  </style>
</head>
<body>
  <div id="splash-screen">
    <div id="menu">
      <select id="level-select">
        <option value="0">Level 1: Spell E-V-A</option>
        <option value="1">Level 2: Alphabet</option>
        <option value="2">Level 3: Count 1-25</option>
        <option value="3">Level 4: Word Bank</option>
      </select>
    </div>
    <button id="start-btn" disabled>LOADING...</button>
  </div>
  
  <div id="ui" style="display:none;">
    <div id="hud">
      <span id="hud-level">Level 1: E-V-A</span>
      <span id="hud-target">Find: E</span>
    </div>
  </div>

  <script>
    // --- AUDIO SETUP ---
    const audio = {
        loop: new Audio('loop.mp3'), pop: new Audio('pop.mp3'),
        magic: new Audio('magic.mp3'), evaTheme: new Audio('eva_theme.mp3'),
        error: new Audio('pop.mp3') // Placeholder for decoy hit sound
    };
    audio.loop.loop = true;
    audio.error.volume = 0.5;

    audio.evaTheme.addEventListener('ended', () => {
        if (state.playing) {
            audio.loop.currentTime = 0; 
            audio.loop.play().catch(()=>{});
        }
    });

    // --- AI VOICE GUIDANCE ---
    function speakTarget(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            const msg = new SpeechSynthesisUtterance("Find " + text);
            const voices = window.speechSynthesis.getVoices();
            const friendlyVoice = voices.find(v => v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Google US English'));
            if(friendlyVoice) msg.voice = friendlyVoice;
            
            msg.rate = 0.9; 
            msg.pitch = 1.2; 
            window.speechSynthesis.speak(msg);
        }
    }

    // Load saved progress
    const savedLevel = localStorage.getItem('evaBusSave') || 0;
    document.getElementById('level-select').value = savedLevel;

    // --- UNIFIED CURRICULUM PIPELINE ---
    const curriculum = [
        { name: "E-V-A", targets: ['E', 'V', 'A'], color: 0xff00ff, skyColor: '#87ceeb' }, 
        { name: "Alphabet", targets: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''), color: 0x00ff55, skyColor: '#ff9966' }, 
        { name: "Count 1-25", targets: Array.from({length: 25}, (_, i) => (i + 1).toString()), color: 0x0088ff, skyColor: '#4a2377' }, 
        { name: "Word Bank", targets: ['A','S','A', 'B','U','S', 'D','O','G', 'C','A','T'], color: 0xffaa00, skyColor: '#0a0a2a' } 
    ];

    const state = {
      playing: false,
      levelIdx: parseInt(savedLevel),
      targetIdx: 0,
      currentTarget: 'E'
    };

    // --- ENGINE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.9);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 8);
    scene.add(dirLight);

    const bubbles = [];
    const clouds = [];
    const bursts = [];
    
    let evaSprite;
    let fullscreenTried = false;
    let gameFont = null;

    // Free Movement Tracker
    const targetEvaPos = new THREE.Vector3(0, -2, 0);
    let isDragging = false;

    // --- MAGIC STARDUST ---
    const starGeo = new THREE.BufferGeometry();
    const starCount = 150;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i < starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 30;
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    
    const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
    const ctx = cvs.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const starTex = new THREE.CanvasTexture(cvs);

    const starMat = new THREE.PointsMaterial({
        size: 0.6, map: starTex, transparent: true, 
        opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const starMesh = new THREE.Points(starGeo, starMat);
    scene.add(starMesh);

    function createBurst(x, y, colorHex) {
        const burstGroup = new THREE.Group();
        burstGroup.position.set(x, y, 0);
        
        const particleGeo = new THREE.PlaneGeometry(0.5, 0.5);
        const particleMat = new THREE.MeshBasicMaterial({
            color: colorHex, map: starTex, transparent: true, 
            opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false
        });

        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.15 + Math.random() * 0.15;
            p.userData = { vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 1.0 };
            burstGroup.add(p);
        }
        scene.add(burstGroup);
        bursts.push(burstGroup);
    }

    function disposeGroup(group) {
        group.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose());
                else child.material.dispose();
            }
        });
    }

    // --- LOAD EVA SOUL ---
    new THREE.TextureLoader().load('eva.png', (tex) => {
        const mat = new THREE.SpriteMaterial({ map: tex });
        evaSprite = new THREE.Sprite(mat);
        evaSprite.scale.set(3, 3, 1);
        evaSprite.position.set(0, -2, 0); 
        scene.add(evaSprite);
    });

    function createMovingClouds() {
        const ccvs = document.createElement('canvas'); ccvs.width = 256; ccvs.height = 128;
        const c = ccvs.getContext('2d');
        c.fillStyle = "rgba(255, 255, 255, 0.6)";
        c.beginPath(); c.arc(128,64,50,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(80,64,35,0,Math.PI*2); c.fill();
        c.beginPath(); c.arc(176,64,35,0,Math.PI*2); c.fill();
        const tex = new THREE.CanvasTexture(ccvs);

        for(let i=0; i<10; i++) {
            const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            s.scale.set(10, 5, 1);
            s.position.set((Math.random()-0.5)*30, Math.random()*10, (Math.random()-0.5)*15 - 5);
            s.userData = { speed: 0.003 + Math.random()*0.008 };
            clouds.push(s); scene.add(s);
        }
    }
    createMovingClouds();

    function createBubble(value, colorHex, x, y, isTarget) {
      if (!gameFont) return null;
      const group = new THREE.Group();

      const textGeo = new THREE.TextGeometry(value.toString(), {
        font: gameFont, size: 0.9, height: 0.2, 
        curveSegments: 12, bevelEnabled: true,
        bevelThickness: 0.02, bevelSize: 0.015, bevelSegments: 3
      });
      
      textGeo.computeBoundingBox();
      const xOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
      const yOffset = -0.5 * (textGeo.boundingBox.max.y - textGeo.boundingBox.min.y);
      
      const textMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6, roughness: 0.2 });
      const textMesh = new THREE.Mesh(textGeo, textMat);
      textMesh.position.set(xOffset, yOffset, 0);
      group.add(textMesh);

      const ringColor = isTarget ? colorHex : 0xaaaaaa; 
      const ringGeo = new THREE.TorusGeometry(1.2, 0.1, 16, 64);
      const ringMat = new THREE.MeshBasicMaterial({ color: ringColor, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
      const ringMesh = new THREE.Mesh(ringGeo, ringMat);
      group.add(ringMesh);

      group.position.set(x, y, 0);
      group.rotation.x = -0.15;
      group.rotation.y = 0.15;

      group.userData = { 
        value, isTarget, colorHex, popScale: 1, popping: false, 
        speed: 0.025 + Math.random()*0.02,
        pulseOffset: Math.random() * Math.PI * 2,
        ringMesh: ringMesh 
      };
      
      scene.add(group);
      bubbles.push(group);
      return group;
    }

    function pulseHUD(id) {
        const el = document.getElementById(id);
        el.style.transform = 'scale(1.4)';
        el.style.color = '#ffeb3b'; 
        setTimeout(() => {
            el.style.transform = 'scale(1)';
            el.style.color = '#ffffff';
        }, 300);
    }

    function updateHud(pulseId = null) {
      const curLvl = curriculum[state.levelIdx];
      document.getElementById('hud-level').textContent = `Level ${state.levelIdx + 1}: ${curLvl.name}`;
      document.getElementById('hud-target').textContent = `Find: ${state.currentTarget}`;
      if (pulseId) pulseHUD(pulseId);
      
      document.body.style.background = curLvl.skyColor;
    }

    function advanceTarget() {
      state.targetIdx++;
      const currentLevel = curriculum[state.levelIdx];

      if (state.targetIdx >= currentLevel.targets.length) {
          if (!audio.loop.paused) audio.loop.pause();
          if (!audio.magic.paused) { audio.magic.pause(); audio.magic.currentTime = 0; }
          if (!audio.evaTheme.paused) { audio.evaTheme.pause(); audio.evaTheme.currentTime = 0; }
          audio.evaTheme.play().catch(()=>{});

          state.levelIdx++;
          if (state.levelIdx >= curriculum.length) state.levelIdx = 0; 
          
          localStorage.setItem('evaBusSave', state.levelIdx);

          state.targetIdx = 0;
          state.currentTarget = curriculum[state.levelIdx].targets[state.targetIdx];
          
          updateHud('hud-level'); 
          speakTarget(state.currentTarget); 
          
      } else {
          audio.magic.currentTime = 0; audio.magic.play().catch(()=>{});
          state.currentTarget = currentLevel.targets[state.targetIdx];
          updateHud('hud-target'); 
          speakTarget(state.currentTarget); 
      }
      
      for (let i = bubbles.length - 1; i >= 0; i--) {
          scene.remove(bubbles[i]);
          disposeGroup(bubbles[i]);
          bubbles.splice(i, 1);
      }
      respawnWave();
    }

    // --- DECOY WAVE SYSTEM (GRAVITY INVERTED) ---
    function respawnWave() {
        const curLvl = curriculum[state.levelIdx];
        const activeColor = curLvl.color;
        const targetVal = state.currentTarget;

        const decoys = [];
        let attempts = 0;
        while(decoys.length < 2 && attempts < 20) {
            const randomVal = curLvl.targets[Math.floor(Math.random() * curLvl.targets.length)];
            if(randomVal !== targetVal && !decoys.includes(randomVal)) {
                decoys.push(randomVal);
            }
            attempts++;
        }
        
        if(decoys.length < 2) {
             decoys.push(curLvl.targets[0] === targetVal ? curLvl.targets[1] : curLvl.targets[0]);
             decoys.push(curLvl.targets[2] === targetVal ? curLvl.targets[1] : curLvl.targets[2]);
        }

        const lanes = [-2.5, 0, 2.5].sort(() => Math.random() - 0.5);
        
        // Spawn them high up (y = 10) so they drop downward toward Eva
        createBubble(targetVal, activeColor, lanes[0], 10, true);
        createBubble(decoys[0], activeColor, lanes[1], 10, false);
        createBubble(decoys[1], activeColor, lanes[2], 10, false);
    }


    function popBubble(group) {
      if (!group || group.userData.popping) return;
      group.userData.popping = true;

      if (group.userData.isTarget) {
          createBurst(group.position.x, group.position.y, group.userData.colorHex);
          audio.pop.currentTime = 0; audio.pop.play().catch(()=>{});
          advanceTarget();
      } else {
          audio.error.currentTime = 0; audio.error.play().catch(()=>{});
          group.userData.popScale = 0.5; 
      }
    }

    // --- FREE MOVEMENT CONTROLS ---
    function updateEvaTarget(clientX, clientY) {
      const vec = new THREE.Vector3(
          (clientX / window.innerWidth) * 2 - 1,
          -(clientY / window.innerHeight) * 2 + 1,
          0.5
      );
      vec.unproject(camera);
      vec.sub(camera.position).normalize();
      const distance = -camera.position.z / vec.z;
      
      const pos = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
      
      targetEvaPos.x = Math.max(-4, Math.min(4, pos.x));
      targetEvaPos.y = Math.max(-5, Math.min(6, pos.y));
    }

    window.addEventListener('pointerdown', (e) => {
      if (!state.playing || e.target.closest('#menu') || e.target.closest('#start-btn')) return;
      isDragging = true;
      updateEvaTarget(e.clientX, e.clientY);
    });

    window.addEventListener('pointermove', (e) => {
      if (!state.playing || !isDragging) return;
      updateEvaTarget(e.clientX, e.clientY);
    });

    window.addEventListener('pointerup', () => { isDragging = false; });
    window.addEventListener('pointercancel', () => { isDragging = false; });

    async function requestFullscreenSafe() {
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } catch (_) {}
    }

    function lockPortraitSafe() {
      try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(() => {}); } catch (_) {}
    }

    const loader = new THREE.FontLoader();
    loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
        gameFont = font;
        const btn = document.getElementById('start-btn');
        btn.textContent = 'RIDE!';
        btn.disabled = false;
    });

    let startRequested = false;
    document.getElementById('start-btn').addEventListener('click', async (e) => {
        e.preventDefault();
        if (startRequested || state.playing || !gameFont) return;
        startRequested = true;

        await requestFullscreenSafe();
        lockPortraitSafe();

        state.levelIdx = parseInt(document.getElementById('level-select').value);
        state.targetIdx = 0;
        state.currentTarget = curriculum[state.levelIdx].targets[0];

        respawnWave();
        
        updateHud(); 
        speakTarget(state.currentTarget); 

        document.getElementById('splash-screen').style.display = 'none';
        
        const ui = document.getElementById('ui');
        ui.style.display = 'flex';
        ui.style.opacity = '0';
        setTimeout(() => { ui.style.transition = 'opacity 0.5s'; ui.style.opacity = '1'; }, 100);

        state.playing = true;
        audio.loop.play().catch(()=>{});
    });

    window.addEventListener('pointerdown', async () => {
      if (fullscreenTried) return;
      fullscreenTried = true;
      if ('speechSynthesis' in window) {
          const msg = new SpeechSynthesisUtterance("");
          msg.volume = 0;
          window.speechSynthesis.speak(msg);
      }
      await requestFullscreenSafe();
      lockPortraitSafe();
    }, { once: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- ANIMATION ENGINE ---
    function animate() {
      requestAnimationFrame(animate);
      
      if (state.playing) {
          clouds.forEach(c => { 
              c.position.x += c.userData.speed; 
              if(c.position.x > 15) c.position.x = -15; 
          });
          
          starMesh.position.y -= 0.02;
          starMesh.rotation.y += 0.001;
          if(starMesh.position.y < -10) starMesh.position.y = 10;

          if (evaSprite) {
              if (isDragging) {
                  evaSprite.position.lerp(targetEvaPos, 0.2);
              } else {
                  evaSprite.position.y += Math.sin(Date.now()*0.003)*0.005;
              }
          }

          for(let i = bursts.length - 1; i >= 0; i--) {
              const b = bursts[i];
              let alive = false;
              b.children.forEach(p => {
                  p.position.x += p.userData.vx;
                  p.position.y += p.userData.vy;
                  p.userData.life -= 0.04; 
                  p.material.opacity = Math.max(p.userData.life, 0);
                  const s = Math.max(p.userData.life, 0);
                  p.scale.set(s, s, s);
                  if (p.userData.life > 0) alive = true;
              });
              if (!alive) {
                  scene.remove(b);
                  disposeGroup(b);
                  bursts.splice(i, 1);
              }
          }

          let needNewWave = false;

          for (let i = bubbles.length - 1; i >= 0; i -= 1) {
            const group = bubbles[i];
            
            if (!group.userData.popping) {
                // GRAVITY INVERTED: Subtract speed to fall downward
                group.position.y -= group.userData.speed;
                group.rotation.y += 0.015;
                group.rotation.x = Math.sin(Date.now()*0.002) * 0.2;
                
                const pulse = 1 + Math.sin(Date.now() * 0.005 + group.userData.pulseOffset) * 0.15;
                group.userData.ringMesh.scale.set(pulse, pulse, 1);

                if (evaSprite && evaSprite.position.distanceTo(group.position) < 1.8) {
                    popBubble(group);
                } else if (group.position.y < -8) { // Despawn when they drop below the screen
                    scene.remove(group);
                    bubbles.splice(i, 1);
                    disposeGroup(group);
                    needNewWave = true;
                }
            } else {
              group.userData.popScale -= 0.15; 
              const s = Math.max(group.userData.popScale, 0);
              group.scale.set(s, s, s); 
              
              if (group.userData.popScale <= 0) {
                scene.remove(group);
                bubbles.splice(i, 1);
                disposeGroup(group);
              }
            }
          }
          
          if (needNewWave && bubbles.length === 0) {
              respawnWave();
          }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
